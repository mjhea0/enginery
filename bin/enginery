#!/usr/bin/env ruby

$:.unshift File.expand_path('../../lib', __FILE__)
require 'enginery'
require 'enginery/usage'

if $*.empty? || $*[0] == 'h' || $*[0] == '-h'
  puts Enginery.usage
  exit 0
end
if $*[0] == 'v' || $*[0] == '-v'
  puts EngineryVersion::FULL
  exit 0
end

root, operation = Dir.pwd, $*[0].to_s

result = catch :enginery_failures do

  case
  when operation[0] == 'g'

    unit = operation.sub(/\Ag(enerate)?\W?/, '')
    args, setups, string_setups = Enginery::Helpers.parse_input(*$*[1..-1])
    generator = Enginery::Generator.new(root, setups)

    if args
      if unit.empty? || unit =~ /\A[p|a]/i
        # generating project
        if generator.generate_project(args[0])
          Dir.chdir generator.dst_root do
            puts "\nRunning bundler ...\n"
            puts %x[bundle install]
            puts %x["#{$0}" g:c Index r:/] # generating Index controller
          end
        end
      else

        generator.fail_unless_in_app_folder!
        generator.load_boot_rb # loading application

        case
        when unit =~ /\Ac(ontroller)?/
          if args.size > 1 # generate multiple controllers
            args.each {|c| puts %x["#{$0}" g:c #{c} #{string_setups}]}
          else
            # generating controller
            if generator.generate_controller(args[0])
              # generating helper file
              puts %x["#{$0}" g:h #{args[0]}]
              
              # generating index route
              puts %x["#{$0}" g:r #{args[0]} index]
            end
          end

        when unit =~ /\Ar(oute)?/
          if args.size > 2 # generate multiple routes
            args[1..-1].each {|u| puts %x["#{$0}" g:r #{args[0]} #{u} #{string_setups}]}
          else
            if generator.generate_route(*args)
              # generating view file
              puts %x["#{$0}" g:v #{args[0]} #{args[1]}]
              
              # generating spec file
              puts %x["#{$0}" g:s #{args[0]} #{args[1]}]
            end
          end

        when unit =~ /\As(pec)?/
          if args.size > 2 # generate multiple specs
            args[1..-1].each {|u| puts %x["#{$0}" g:s #{args[0]} #{u} #{string_setups}]}
          else
            generator.generate_spec(*args)
          end

        when unit =~ /\Ah(elper)?/
          generator.generate_helper(*args)

        when unit =~ /\Av(iew)?/
          generator.generate_view(args[0], args[1])

        when unit =~ /\Am(odel)?/
          if args.size > 1 # generate multiple models
            args.each {|m| puts %x["#{$0}" g:m #{m} #{string_setups}]}
          else
            if generator.generate_model(args[0])
              puts %x["#{$0}" m initializing-#{args[0]}-model create_table_for:#{args[0]} #{string_setups}]
            end
          end
        end

      end
    end

  when operation[0] == 'm'

    operation = operation.sub(/\Am(igrat(e)?(ion)?)?(\W+)?/, '')
    args, setups, string_setups = Enginery::Helpers.parse_input(*$*[1..-1])
    migrator = Enginery::Migrator.new(root, setups)

    migrator.fail_unless_in_app_folder!
    migrator.load_boot_rb # loading application

    if operation.empty? || operation =~ /\An(ew)?/ # new migration
      migrator.new args[0]
    elsif operation =~ /\Al(ist)?/
      migrator.list
    else
      vector, extra = operation.scan(/(\w+)\:?(\w+)?/).flatten
      force_run, force_yes = extra ? [extra.match(/\Af/i), extra.match(/\Ay/i)] : []
      
      if file = setups[:file]
        migrator.run(vector, file, force_run)
      else
        files = migrator.serials_to_files(vector, *args)
        
        if files.empty?
          outstanding_files = migrator.outstanding_migrations(vector)
          
          if force_yes
            files = outstanding_files
          else
            puts 'This will run all outstanding migrations in the following order:'
            puts
            puts outstanding_files.map {|f| f[/\A\d+/]}*' '
            puts
            puts '  Type Y and press enter to Continue'
            puts '  Press enter to Abort'
            puts '  Use :yes options to get rid of this prompt - enginery m:%s:yes ...' % vector
            answer = STDIN.gets.strip
            files  = outstanding_files if answer.match(/\Ay/i)
          end
        end
        
        if files.empty?
          puts
          puts 'Nothing to run, exiting'
          puts
          exit 0
        end

        failed = false
        files.each do |file|
          (puts("\n  %s skipped due to previous errors\n" % file); next) if failed
          puts %x["#{$0}" m:#{vector}:#{force_run} f:#{file} #{string_setups}]
          $? ? (failed = true if $?.exitstatus > 0) : (failed = true)
        end
        puts
        exit(1) if failed

      end
    end

  when operation[0..5] == 'delete'

    operation = operation.sub(/\Ad(elete)?(\W+)?/, '')
    unit, extra = operation.scan(/(\w+)\:?(\w+)?/).flatten
    force_run, force_yes = extra ? [extra.match(/\Af/i), extra.match(/\Ay/i)] : []
    args, setups, string_setups = Enginery::Helpers.parse_input(*$*[1..-1])

    case
    when unit =~ /\Ac(ontroller)?/
      delete_meth, delete_args, required_args = :controller, args[0..0], 1
    when unit =~ /\Ar(oute)?/
      delete_meth, delete_args, required_args = :route, args[0..1], 2
    when unit =~ /\Av(iew)?/
      delete_meth, delete_args, required_args = :view, args[0..1], 2
    when unit =~ /\As(pec)?/
      delete_meth, delete_args, required_args = :view, args[0..1], 2
    when unit =~ /\Ah(elper)?/
      delete_meth, delete_args, required_args = :helper, args[0..0], 1
    when unit =~ /\Amo(del)?/
      delete_meth, delete_args, required_args = :model, args[0..0], 1
    when unit =~ /\Ami(gration)?/
      delete_meth, delete_args, required_args = :migration, args[0..0], 1
    else
      delete_meth = nil
    end

    if delete_meth
      delete_args.size == required_args ||
        Enginery::Helpers.fail('Please provide %s name' % delete_meth)

      unless run = force_run || force_yes
        puts
        puts '  You are about to delete "%s" %s!' % [delete_args*"#", delete_meth]
        puts
        puts '  This action can not be undone!'
        puts
        puts '  Type Y and press enter to Continue'
        puts '  Press enter to Abort'
        puts '  Use :yes options to get rid of this prompt - enginery d:%s:yes ...' % unit
        answer = STDIN.gets.strip
        run = true if answer.match(/\Ay/i)
      end
      if run
        delete = Enginery::Delete.new(root)
        delete.load_boot_rb
        delete.send delete_meth, *delete_args
      end
    else
      Enginery::Helpers.fail '--- Unknown unit "%s" ---' % unit
    end

  else
    puts "\n--- Unknown modifier %s ---\n" % operation.split(':').first
    puts "use one of g[enerate], m[igration], delete\n"
    puts Enginery.usage
    exit 1
  end
end

if result.is_a?(Enginery::Failure)
  puts '', '  *** Operation FAILED ***'
  result.failures.each {|f| puts '  %s' % f}
  puts
  exit 1
end
